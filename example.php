<?php

   require_once('yubikey.php');

   /* Generated by the YubiKey (example) */
   $otp = "thgegbdkbjgvlecttgrcjltlvebjubdnlurfhvnrubui";

   /* 128-bit private key for AES decryption */
   $secret_key = "\xcc\x67\x43\x5a\x35\x4e\xd5\x1c\x00\xcc\xc3\xbd\x61\xd6\xfb\xb9";

   /* Last authenticated counters; a number smaller than this means used OTP */
   $usage_counter = 5;
   $session_counter = 1;

   function auth_user($otp, $key, &$usage_counter, &$session_counter) {
      $y = new YubiParser($otp);
      $pubid = $y->getIdentity(); /* Returns the public ID, in this case 'thgegbdkbjgv' */
      $otp = $y->getOTP($key);    /* Decrypt the OTP into a YubiOTP object */

      /* Did it parse OK? */
      if (!$otp)
         die("$pubid: unable to decode OTP\n");

	   /* Is the checksum OK? This is how we catch incorrect decryption keys (which
       * would just generate garbage data) 
       */
	   if (!$otp->validChecksum())
		   die("$pubid: Integrity failure\n");
	
      /* Perform authentication, do not allow old passwords */
	   if ($otp->usage_counter < $usage_counter)
		   die("$pubid: used/spent token (usage)\n");

	   if ($usage_counter == $otp->usage_counter && 
          $otp->session_counter <= $session_counter)
		   die("$pubid: used/spent token (session)\n");

     /* User successfully authenticated; increment the counters so this OTP
      * isn't accepted if re-used.
      */

      $usage_counter = $otp->usage_counter;
      $session_counter = $otp->session_counter;

      echo("$pubid: authenticated successfully! usage=$usage_counter session=$session_counter\n");
   }

   /* Should succeed, this is the first time $otp is used to authenticate */
   auth_user($otp, $secret_key, $usage_counter, $session_counter);

   /* Should fail, because the same OTP is re-used */
   auth_user($otp, $secret_key, $usage_counter, $session_counter);

?>
